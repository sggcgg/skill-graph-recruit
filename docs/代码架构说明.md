# 代码架构说明

## scripts/ vs src/ 的区别

### 📦 src/ - 核心模块（库代码）

**定位**：可复用的功能模块，提供类和函数

**特点**：
- 提供具体实现
- 不包含用户交互
- 可被其他代码导入使用
- 专注于功能逻辑

**示例**：
```python
# src/graph_builder/neo4j_importer.py
class Neo4jImporter:
    """Neo4j导入器类"""
    def import_jobs(self, jobs):
        # 具体的导入逻辑
        pass

def import_data_pipeline(skill_dict_path, ...):
    """完整的导入流程函数"""
    # 封装好的导入流程
    pass
```

### 🚀 scripts/ - 可执行脚本（工具脚本）

**定位**：用户直接运行的脚本，提供完整的工作流

**特点**：
- 包含用户交互（输入、确认、进度显示）
- 调用 `src/` 中的模块
- 提供完整的使用流程
- 易于命令行使用

**示例**：
```python
# scripts/reimport_neo4j.py
from src.graph_builder.neo4j_importer import import_data_pipeline

def reimport_all():
    # 1. 用户交互
    print("请选择数据源...")
    choice = input()
    
    # 2. 数据准备
    data_files = load_data()
    
    # 3. 确认操作
    confirm = input("确认清空数据库？")
    
    # 4. 调用核心模块
    import_data_pipeline(...)  # ← 调用 src/ 中的函数
    
    # 5. 显示结果
    print("导入完成！")

if __name__ == '__main__':
    reimport_all()
```

## Neo4j导入的两个文件

### src/graph_builder/neo4j_importer.py（核心实现）

**作用**：提供Neo4j导入的核心功能

**主要内容**：
```python
class Neo4jImporter:
    """Neo4j导入器类"""
    def __init__(self, uri, user, password, skill_dictionary):
        # 初始化连接
        
    def create_indexes(self):
        # 创建索引
        
    def import_skills_from_dictionary(self, skill_dictionary):
        # 导入技能节点
        
    def import_jobs(self, jobs, batch_size=100):
        # 导入岗位节点和关系
        
    def build_skill_relationships(self):
        # 构建技能关联关系
        
    def update_statistics(self):
        # 更新统计信息

def import_data_pipeline(skill_dict_path, cleaned_data_paths, ...):
    """
    完整的导入流程（封装好的函数）
    
    这是一个便捷函数，内部会：
    1. 创建 Neo4jImporter 实例
    2. 创建索引
    3. 导入技能词典
    4. 导入岗位数据
    5. 构建关系
    6. 更新统计
    """
    importer = Neo4jImporter(...)
    importer.create_indexes()
    importer.import_skills_from_dictionary(skill_dict)
    importer.import_jobs(all_jobs)
    importer.build_skill_relationships()
    importer.update_statistics()
```

**使用方式**：
```python
# 方式1：直接使用类（灵活，自己控制流程）
from src.graph_builder.neo4j_importer import Neo4jImporter

importer = Neo4jImporter(uri, user, password, skill_dict)
importer.create_indexes()
importer.import_jobs(jobs)

# 方式2：使用封装函数（简单，一步到位）
from src.graph_builder.neo4j_importer import import_data_pipeline

import_data_pipeline(
    skill_dict_path='data/skill_dict/skill_taxonomy.json',
    cleaned_data_paths=['data/cleaned/boss_北京_cleaned.json'],
    neo4j_uri='neo4j://localhost:7687',
    neo4j_user='neo4j',
    neo4j_password='password'
)
```

### scripts/reimport_neo4j.py（用户脚本）

**作用**：提供友好的命令行界面，引导用户完成导入

**主要功能**：
1. ✅ **数据源选择**：自动检测增强数据和清洗数据
2. ✅ **清空数据库**：询问确认，批量删除旧数据
3. ✅ **数据统计**：显示将要导入的数据信息
4. ✅ **进度显示**：实时显示导入进度
5. ✅ **结果展示**：显示导入统计和下一步操作
6. ✅ **错误处理**：友好的错误提示

**执行流程**：
```
运行: python scripts/reimport_neo4j.py

┌─────────────────────────────────────────┐
│ 1. 选择数据源                            │
│    - 检测 data/enhanced/ (LLM增强)      │
│    - 检测 data/cleaned/ (仅规则)        │
│    - 让用户选择                          │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 2. 清空数据库                            │
│    - 显示当前节点/关系数                 │
│    - 询问确认                            │
│    - 批量删除                            │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 3. 数据统计                              │
│    - 统计岗位数量                        │
│    - 计算平均技能数                      │
│    - 显示数据类型                        │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 4. 调用导入核心                          │
│    import_data_pipeline(...)            │  ← 调用 neo4j_importer.py
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 5. 显示结果                              │
│    - 导入统计                            │
│    - Neo4j查询示例                       │
│    - 下一步建议                          │
└─────────────────────────────────────────┘
```

## 为什么这样设计？

### 优点

#### 1. 职责分离
```
src/        → 专注功能实现（可测试、可复用）
scripts/    → 专注用户体验（交互、流程）
```

#### 2. 复用性强
```python
# neo4j_importer.py 可以在多个地方使用：

# 场景1：命令行脚本
# scripts/reimport_neo4j.py
from src.graph_builder.neo4j_importer import import_data_pipeline
import_data_pipeline(...)

# 场景2：API接口
# src/api/main.py
from src.graph_builder.neo4j_importer import Neo4jImporter
importer = Neo4jImporter(...)

# 场景3：测试代码
# tests/test_neo4j_import.py
from src.graph_builder.neo4j_importer import Neo4jImporter
def test_import():
    importer = Neo4jImporter(...)
    assert importer.import_jobs(...) > 0
```

#### 3. 易于维护
```
修改导入逻辑       → 只需改 neo4j_importer.py
修改用户界面       → 只需改 reimport_neo4j.py
添加新的导入脚本   → 直接复用 neo4j_importer.py
```

#### 4. 层次清晰
```
应用层 (scripts/)   →  用户交互、流程控制
  ↓ 调用
业务层 (src/)       →  核心功能、业务逻辑
  ↓ 调用
数据层 (Neo4j)      →  数据存储
```

## 类比理解

### 类比1：餐厅

| 角色 | 对应 | 职责 |
|------|------|------|
| **厨师** | `neo4j_importer.py` | 做菜（核心功能） |
| **服务员** | `reimport_neo4j.py` | 点菜、上菜、结账（用户交互） |
| **顾客** | 你 | 使用服务 |

你不会直接找厨师点菜，而是通过服务员。但厨师的手艺（核心功能）可以服务多个餐厅（多个脚本）。

### 类比2：图书馆

| 角色 | 对应 | 职责 |
|------|------|------|
| **书籍** | `neo4j_importer.py` | 存储知识（功能实现） |
| **图书管理员** | `reimport_neo4j.py` | 帮你找书、借还书（用户界面） |
| **读者** | 你 | 使用图书馆 |

## 其他类似的文件对

### 1. LLM增强

| 核心模块 | 用户脚本 |
|---------|---------|
| `src/nlp/hybrid_skill_extractor.py` | `scripts/enhance_skills_with_llm.py` |
| 提供 `HybridSkillExtractor` 类 | 提供用户交互和批量处理 |

### 2. 向量数据库

| 核心模块 | 用户脚本 |
|---------|---------|
| `src/rag/vector_db.py` | `scripts/init_vector_db.py` |
| 提供 `VectorDB` 类 | 提供初始化流程和进度显示 |

### 3. 数据清洗

| 核心模块 | 用户脚本 |
|---------|---------|
| `src/data_processing/data_cleaner.py` | `run_pipeline.py` |
| 提供 `DataCleaner` 类 | 提供完整的数据处理流程 |

## 如何选择使用？

### 情况1：我是普通用户，想导入数据
```bash
# 直接运行脚本
python scripts/reimport_neo4j.py
```
**原因**：脚本提供了完整的交互式流程

### 情况2：我是开发者，想在代码中导入
```python
# 导入核心模块
from src.graph_builder.neo4j_importer import import_data_pipeline

import_data_pipeline(
    skill_dict_path='...',
    cleaned_data_paths=['...'],
    neo4j_uri='...',
    neo4j_user='...',
    neo4j_password='...'
)
```
**原因**：直接使用核心功能，无需交互

### 情况3：我想自定义导入流程
```python
# 使用类进行细粒度控制
from src.graph_builder.neo4j_importer import Neo4jImporter

importer = Neo4jImporter(uri, user, password, skill_dict)

# 自定义流程
importer.create_indexes()
# 只导入部分数据
importer.import_jobs(filtered_jobs)
# 跳过某些步骤
# importer.build_skill_relationships()  # 不执行这步
```
**原因**：需要更灵活的控制

## 总结

```
┌─────────────────────────────────────────────────────────┐
│                      你（用户）                          │
└─────────────────────────────────────────────────────────┘
                          ↓
                  运行命令行脚本
                          ↓
┌─────────────────────────────────────────────────────────┐
│              scripts/reimport_neo4j.py                   │
│  - 用户交互（选择、确认、进度）                           │
│  - 流程控制（清空、统计、导入）                           │
│  - 结果展示（统计、建议）                                 │
└─────────────────────────────────────────────────────────┘
                          ↓
                  调用核心模块
                          ↓
┌─────────────────────────────────────────────────────────┐
│          src/graph_builder/neo4j_importer.py             │
│  - Neo4jImporter 类（核心实现）                          │
│  - import_data_pipeline 函数（封装流程）                 │
│  - 具体的导入逻辑                                         │
└─────────────────────────────────────────────────────────┘
                          ↓
                  操作数据库
                          ↓
┌─────────────────────────────────────────────────────────┐
│                    Neo4j 数据库                          │
└─────────────────────────────────────────────────────────┘
```

**简单记忆**：
- **src/**: "能力"（我能做什么）
- **scripts/**: "服务"（怎么方便地使用这些能力）

你使用 `scripts/reimport_neo4j.py` 是因为它提供了友好的交互界面和完整的流程，而它内部调用了 `src/graph_builder/neo4j_importer.py` 来完成实际的导入工作。
